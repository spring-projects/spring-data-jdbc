/*
 * Copyright 2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.springframework.data.jdbc.testing;

import static org.assertj.core.api.Assumptions.*;

import java.util.Arrays;
import java.util.Locale;

import org.springframework.jdbc.core.ConnectionCallback;
import org.springframework.jdbc.core.JdbcOperations;

/**
 * This class provides information about which features a database integration supports in order to react on the
 * presence or absence of features in tests.
 *
 * @author Jens Schauder
 */
public class TestDatabaseFeatures {

	private final Database database;

	public TestDatabaseFeatures(JdbcOperations jdbcTemplate) {

		String productName = jdbcTemplate.execute(
				(ConnectionCallback<String>) c -> c.getMetaData().getDatabaseProductName().toLowerCase(Locale.ENGLISH));

		database = Arrays.stream(Database.values()).filter(db -> db.matches(productName)).findFirst().get();
	}

	/**
	 * Oracle returns an oracle.sql.TIMESTAMP which currently cannot be converted to an Instant.
	 *
	 * See DATAJDBC-569 for reference.
	 */
	public void supportsDateDataTypes() {
		assumeThat(database).isNotEqualTo(Database.Oracle);
	}

	/**
	 * Not all databases support really huge numbers as represented by {@link java.math.BigDecimal} and similar.
	 */
	public void supportsHugeNumbers() {
		assumeThat(database).isNotIn(Database.Oracle, Database.SqlServer);
	}

	/**
	 * Oracle does not allow to specify an alias for a joined table with {@code AS}.
	 *
	 * See DATAJDBC-570 for reference.
	 */
	public void supportsAsForJoinAlias() {
		assumeThat(database).isNotEqualTo(Database.Oracle);
	}

	/**
	 * Oracles JDBC driver seems to have a bug that makes it impossible to acquire generated keys when the column is quoted.
	 *
	 * See https://stackoverflow.com/questions/62263576/how-to-get-the-generated-key-for-a-column-with-lowercase-characters-from-oracle
	 */
	public void supportsQuotedIds() {
		assumeThat(database).isNotEqualTo(Database.Oracle);
	}

	/**
	 * Microsoft SqlServer does not allow explicitly setting ids in columns where the value gets generated by the database.
	 * Such columns therefore must not be used in referenced entities, since we do a delete and insert, which must not recreate an id.
	 *
	 * See https://jira.spring.io/browse/DATAJDBC-210
	 */
	public void supportsGeneratedIdsInReferencedEntities() {
		assumeThat(database).isNotEqualTo(Database.SqlServer);
	}

	public void supportsArrays() {

		assumeThat(database).isNotIn(Database.MySql,
				// mariadb,
				Database.SqlServer, Database.Db2, Database.Oracle);
	}

	public void supportsMultiDimensionalArrays() {

		supportsArrays();
		assumeThat(database).isNotIn(Database.H2, Database.Hsql);
	}

	public void databaseIs(Database database) {
		assumeThat(this.database).isEqualTo(database);
	}

	public enum Database {
		Hsql, H2, MySql, PostgreSql, SqlServer("microsoft"), Db2, Oracle;

		private final String identification;

		Database(String identification) {
			this.identification = identification;
		}

		Database() {
			this.identification = null;
		}

		boolean matches(String productName) {

			String identification = this.identification == null ? name().toLowerCase() : this.identification;
			return productName.contains(identification);
		}
	}
}
